name: Label Handler
on:
  merge_group:
    types: [checks_requested]
  pull_request:
    types:
      - labeled
      - unlabeled
      - opened
      - edited
      - reopened
      - synchronize
      - ready_for_review
  issues:
    types:
      - labeled
      - unlabeled
  discussion:
    types:
      - labeled
      - unlabeled
  issue_comment:
    types:
      - created
  discussion_comment:
    types:
      - created
env:
  # use embedded GITHUB_TOKEN https://docs.github.com/ja/actions/reference/authentication-in-a-workflow#
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  BODY: ${{ github.event.comment.body }}
permissions:
  id-token: write
  issues: write
  pull-requests: write
jobs:
  label-handler:
    timeout-minutes: 5
    runs-on: [self-hosted, organization]
    if: (github.event_name == 'pull_request' && github.actor != 'dependabot[bot]') || github.event_name == 'issues'
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const m = {
              'do-not-merge': '🙅【DO NOT MERGE】🙅\n「do-not-merge」ラベルが付いています。\nこのプルリクエストはマージできません。',
              'keel-translate': '🌏【翻訳】🌏\n「keel-translate」ラベルが付いています。\n自動翻訳が有効になります。'
            }

            if (context.payload.action === 'labeled' || context.payload.action === 'unlabeled') {
              let issue_number;
              if (context.payload.pull_request) {
                issue_number = context.payload.pull_request.number;
              } else if (context.payload.issue) {
                issue_number = context.payload.issue.number;
              }

              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue_number,
              });

              for (const comment of comments.data) {
                for (const body of Object.values(m)) {
                  if (comment.body.includes(body)) {
                    await github.rest.issues.deleteComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: comment.id,
                    });
                  }
                }
              }

              for (const label of context.payload.pull_request.labels) {
                if (m[label.name]) {
                  await github.rest.issues.createComment({
                    issue_number: context.payload.pull_request.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: m[label.name]
                  });
                }
              }
            }
      - name: Check for do-not-merge label
        run: exit 1
        if: contains(github.event.pull_request.labels.*.name, 'do-not-merge') == true
  keel-translate:
    timeout-minutes: 5
    runs-on: [self-hosted, organization]
    steps:
      - name: Translate the created comment
        env:
          MODEL: gpt-4o
        run: |
          function keelai() {
            ID_TOKEN=$(curl -sSL -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${GITHUB_ACTION_PATH}" | jq -r .value)
            response=$(curl -sSL -X POST -H "Authorization: Bearer $ID_TOKEN" -H "Content-Type: application/json" https://keelai-api-vpce.k8s.nxin.jp/v1/chat/completions -d "$(echo $@ | jq -sc --arg model "$MODEL" '. as $messages | {"model": $model, "messages": $messages}')")

            if [ "$(echo $response | jq -r '.error')" != "null" ]; then
              echo $response | jq -r '.error' 1>&2
              exit 1
            fi

            echo $response | jq -r '.choices[0].message.content'
          }

          systemPrompt=$(cat <<'EOS'
          Translate this text to English.
          EOS
          )
          userPrompt="$BODY"

          system=$(jq -n --arg role "system" --arg content "$systemPrompt" '{"role": $role, "content": $content}')
          user=$(jq -n --arg role "user" --arg content "$userPrompt" '{"role": $role, "content": $content}')
          body=$(keelai "$system" "$user")

          newComment=$(cat <<EOS
          $BODY

          <details>
          <summary>keel-translated English</summary>
          $body
          </details>
          EOS
          )

          echo "BODY=$newComment" >> $GITHUB_ENV

          curl -sSL -X PATCH -H "Authorization: token ${GITHUB_TOKEN}" -d "$(jq -n --arg body "$newComment" '{$body}')" ${{ github.event.comment.url }}
        if: (contains(github.event.pull_request.labels.*.name, 'keel-translate') == true || contains(github.event.issue.labels.*.name, 'keel-translate') == true || contains(github.event.discussion.labels.*.name, 'keel-translate') == true) && (github.event_name == 'issue_comment' || github.event_name == 'discussion_comment')
